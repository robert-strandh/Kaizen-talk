\documentclass{slides}
\usepackage[utf8]{inputenc}
\usepackage{graphics}
\usepackage{portland}
\usepackage{epsfig}
\usepackage{alltt}
\usepackage{moreverb}
\usepackage{url}
\usepackage[dvips,usenames]{color}

\definecolor{MyLightMagenta}{rgb}{1,0.7,1}
\definecolor{darkgreen}{rgb}{0.1,0.7,0.1}

\newcommand{\darkgreen}[1]{\textcolor{darkgreen}{#1}}
\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\thistle}[1]{\textcolor{Thistle}{#1}}
\newcommand{\apricot}[1]{\textcolor{Apricot}{#1}}
\newcommand{\melon}[1]{\textcolor{Melon}{#1}}
\newcommand{\dandelion}[1]{\textcolor{Dandelion}{#1}}
\newcommand{\green}[1]{\textcolor{OliveGreen}{#1}}
\newcommand{\lavender}[1]{\textcolor{Lavender}{#1}}
\newcommand{\mylightmagenta}[1]{\textcolor{MyLightMagenta}{#1}}
\newcommand{\blue}[1]{\textcolor{RoyalBlue}{#1}}
\newcommand{\darkorchid}[1]{\textcolor{DarkOrchid}{#1}}
\newcommand{\orchid}[1]{\textcolor{Orchid}{#1}}
\newcommand{\brickred}[1]{\textcolor{BrickRed}{#1}}
\newcommand{\peach}[1]{\textcolor{Peach}{#1}}
\newcommand{\bittersweet}[1]{\textcolor{Bittersweet}{#1}}
\newcommand{\salmon}[1]{\textcolor{Salmon}{#1}}
\newcommand{\yelloworange}[1]{\textcolor{YellowOrange}{#1}}
\newcommand{\periwinkle}[1]{\textcolor{Periwinkle}{#1}}

\newcommand{\names}[1]{\periwinkle{#1}}
\newcommand{\motcle}[1]{\mylightmagenta{#1}}
\newcommand{\classname}[1]{\darkgreen{#1}}
\newcommand{\str}[1]{\yelloworange{#1}}
\newcommand{\defun}[1]{\orchid{#1}}
\newcommand{\ti}[1]{\begin{center}\Large{\textcolor{blue}{#1}}\end{center}}
\newcommand{\alert}[1]{\thistle{#1}}
\newcommand{\lispprint}[1]{\dandelion{#1}}
\newcommand{\lispvalue}[1]{\red{#1}}
\newcommand{\tr}[1]{\texttt{\red{#1}}}
\newcommand{\emc}[1]{\red{#1}}
\newcommand{\lispobj}[1]{\green{\texttt{#1}}}
\def\prompt{{\textcolor{Orchid}{CL-USER>}}}
\newcommand{\promptp}[1]{\textcolor{Orchid}{#1>}}

\newcommand{\Comment}[1]{
\begin{center}
\textcolor{yellow}
{#1}
\end{center}
}

\def\bs{$\backslash$}
\def\inputfig#1{\input #1}
\def\inputtex#1{\input #1}

\begin{document}
\landscape
\setlength{\oddsidemargin}{1cm}
\setlength{\evensidemargin}{1cm}
\setlength{\marginparwidth}{1cm}
\setlength{\parskip}{0.5cm}
\setlength{\parindent}{0cm}
%-----------------------------------------------------------
\begin{slide}\ti{Choosing a programming language}
\vskip 0.5cm
\begin{center}
Robert Strandh \\
Universit√© de Bordeaux \\
Bordeaux, France
\end{center}
\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Overview of talk}

  \begin{itemize}
  \item Programming language characteristics.
  \item Risk analysis.
  \end{itemize}

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{How the choice is often made}

The choice of programming language for a project (when there are
several possibilities) if often based on \emph{gut feeling}.

Often, no real analysis is made, because the decision maker:

\begin{itemize}
\item has only partial knowledge of the characteristics of possible
  choices;
\item sometimes has incorrect information about the possible choices;
\item has insufficient training to appreciate the characteristics of
  possible choices;
\end{itemize}

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{How the choice is often made}

Often, no real analysis is made, because the decision maker:

\begin{itemize}
\item has insufficient experience with the possible choices to
  determine which choice is adapted to the current project;
\item has insufficient information about the cost associated with
  training staff in a new language vs the productivity advantages of
  that language;
\item has insufficient information about the cost associated with
  hiring new staff for a new language vs the productivity advantages of
  that language.
\end{itemize}

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Language vs implementation}

Language: A description of the syntax and semantics of conforming
programs, and of consequences of using non-conforming constructs.

Example of the latter: In C, obtaining a pointer beyond an array has
undefined consequences.  (It is interesting to contemplate why)

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Language vs implementation}

Implementation: Software that accepts conforming programs and executes
them according to the language semantics, and that reports
non-conforming constructs where required by the language definition.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Language vs implementation}

The distinction language/implementation is sometimes blurred:

\begin{itemize}
\item Some languages are defined by a \emph{reference
  implementation}.  Examples?
\item Some language definitions are controlled by the same
  organization that supplies some dominating implementation.
  Examples?
\end{itemize}

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Strong vs weak typing}

A language can be \emph{strongly typed} or \emph{weakly typed}, and
even \emph{untyped}.

Strongly typed: It is impossible for an object of one type to be
mistakenly taken for an object of a different type, either because the
compiler made sure it won't happen, or because the run-time system
checked it.

Weakly typed: No such guarantees are made.

Untyped: Neither the compiler nor the run-time system intervenes.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Static vs dynamic typing}

A language can be \emph{statically typed} or \emph{dynamically
  typed}.

Static typing: Type information is associated with the
\emph{variables} in the program.  Type checking or type inference is
always handled at compile time.

Dynamic typing: Type information is associated with the \emph{objects}
manipulated by the program.  Type checking must sometimes be done at
execution time.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Manifest vs implicit typing}

A statically-typed programming language may be based on \emph{manifest
  typing} or \emph{implicit typing}.

Manifest typing: The programmers supplies the type of the variables
explicitly.

Implicit typing (sometimes called \emph{latent} typing): The compiler
\emph{infers} the type of the variables from the operations it
participates in.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Manifest vs implicit typing}

Why is the distinction between manifest and implicit typing important?

With manifest typing, the programmers is given too much responsibility
too early in the development process.  Choices made may easily change
later on.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Static vs dynamic}

A programming language can be either \emph{static} or \emph{dynamic}.

Static: There is a clear distinction between \emph{compile time} and
\emph{run time}.  Code is \emph{generated} at compile time and
\emph{executed} at run time.

Dynamic: There is no clear distinction between \emph{compile time} and
\emph{run time}.  The program might change as a result of executing
code (for example, executing a statement that defines a function or a
class).

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Interpreted vs compiled}

Can you guess what an \emph{interpreted programming language} is and
what a \emph{compiled programming language} might be?

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Interpreted vs compiled}

Can you guess what an \emph{interpreted programming language} is and
what a \emph{compiled programming language} might be?

A programming \emph{language} is neither interpreted nor compiled.  A
programming language \emph{implementation} is either one or both (it
is a spectrum of possibilities).

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Interpreted vs compiled}

The distinction is important because it affects the \emph{execution
  performance} of the program.

An implementation that compiles to native code has the potential of
generating \emph{fast} code.

An implementation that has more elements of interpretation can
generate code that is slower by a factor 10 or more compared to code
generated by a native compiler.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Manual vs automatic memory management}

Manual memory management: The language requires the programmer to
de-allocate objects that are no longer going to be referenced.

Automatic memory management: The language automatically recycles
objects that are no longer referenced.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Scripting languages}

There are few properties that characterize scripting languages.
Probably only:

\begin{itemize}
\item The creators meant for the language to be used for scripting.
\item It is a dynamic language.
\end{itemize}

Common scripting languages are single-implementation languages with
the implementation written as a slow interpreter.  This technique is
considered acceptable because of the first item above.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Common misconceptions}

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Manual vs automatic memory management}

Common misconception: manual memory management is faster than
automatic memory management.

With manual memory management, for modularity, it is often necessary
to copy objects or to use reference counters.

Such techniques can easily incur a performance penalty of a factor
10--100 on modern hardware.  Why?

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Compiled/static vs interpreted/dynamic}

Common misconception: dynamic languages must be interpreted.

Conversely: only static languages can be compiled.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Risk analysis}

For every major possible choice (tools, staff, development method,
etc.), make a list of possible events that might have a negative
impact on the project.

For each event, state:

\begin{itemize}
\item its likelihood,
\item the cost to the project if nothing is done,
\item actions to avoid the negative impact, and
\item the cost of those actions.
\end{itemize}

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Risk analysis}

Example:

Choice: Make Joe a member of the staff.  Joe is a reckless driver.

Event: Joe has a traffic accident and can no longer work on the
project.

Likelihood: Unlikely

Cost if nothing is done: The project will be delayed by six months.

Action: Hire a replacement for Joe.

Cost of action: Salary, training, etc.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Risk analysis}

Example:

Choice: Use the language C\#.

Event: Microsoft is bought by Apple (or Google) and C\# is no longer
supported.

Likelihood: Unlikely

Cost if nothing is done: All code must be rewritten in Java.

Action: Obtain (buy, develop) a replacement for Microsoft C\#.

Cost of action: Cost of purchase or development.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Standardization}

A language is said to have an \emph{independent standard} if and only
if the definition of the language is published by an organization
other than a supplier of an implementation.

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Standardization and risk analysis}

If a language does not have an independent standard, its specification
may change as a result of the organization that supplies the
implementation.

The cost to a project could be huge.  Much code may need to be
rewritten, perhaps not immediately, but over time.

Such possibilities must be taken into account in the risk analysis.

Examples?

\vfill\end{slide}
%-----------------------------------------------------------
\begin{slide}\ti{Availability of good implementations}

A good implementation may exist when a project is started, but might
then be abandoned over time.

Again, the cost to a project could be huge, including a complete
rewrite using a different language.

Such possibilities must be taken into account in the risk analysis.

Examples?

\vfill\end{slide}
%-----------------------------------------------------------
%% \begin{slide}\ti{}

%% \vfill\end{slide}
%-----------------------------------------------------------
%% \begin{slide}\ti{}

%% \vfill\end{slide}
%% %-----------------------------------------------------------
%% \begin{slide}\ti{}

%% \vfill\end{slide}
%--------------------------------

\end{document}
 
